<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klondike Solitaire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            background-color: #15803d;
            display: flex;
            flex-direction: column;
            padding: 6px;
            overflow: hidden;
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .status-info {
            text-align: center;
            color: #bbf7d0;
            font-size: 13px;
            font-weight: 500;
            opacity: 0.9;
            min-width: 60px;
        }

        .win-counter {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.2;
        }

        .win-count-number {
            font-size: 16px;
            font-weight: bold;
            color: #86efac;
        }

        .win-count-label {
            font-size: 11px;
            color: #bbf7d0;
            opacity: 0.8;
        }

        .button-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .new-game-btn {
            background-color: #2563eb;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            border: none;
            cursor: pointer;
            min-height: 44px;
            min-width: 60px;
        }

        .auto-win-btn {
            background-color: #059669;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            border: none;
            cursor: pointer;
            min-height: 44px;
            min-width: 80px;
        }

        .undo-btn {
            background-color: #7c3aed;
            color: white;
            padding: 8px;
            border-radius: 8px;
            font-size: 18px;
            border: none;
            cursor: pointer;
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .undo-btn:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .undo-btn:not(:disabled):hover {
            background-color: #6d28d9;
        }

        .undo-icon {
            display: inline-block;
            transform: scaleX(-1);
        }

        .win-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .win-popup-content {
            background-color: white;
            padding: 32px 24px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 320px;
            width: 90%;
        }

        .win-popup h2 {
            color: #15803d;
            font-size: 26px;
            margin-bottom: 16px;
            font-weight: bold;
        }

        .win-popup p {
            color: #4b5563;
            margin-bottom: 24px;
            font-size: 16px;
            line-height: 1.4;
        }

        .win-popup-btn {
            background-color: #2563eb;
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 18px;
            border: none;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            min-height: 56px;
        }

        .top-area {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stock-waste {
            display: flex;
            gap: 6px;
        }

        .foundations {
            display: flex;
            gap: 6px;
        }

        .card {
            width: 58px;
            height: 78px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            position: relative;
            overflow: hidden;
            background: none;
            border: none;
            min-height: 44px;
            min-width: 44px;
        }

        .card-face-down {
            background-color: #1e40af;
            border: 1px solid #4b5563;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-back-pattern {
            width: 38px;
            height: 58px;
            background-color: #1e3a8a;
            border-radius: 6px;
            border: 1px solid #3b82f6;
        }

        .card-face-up {
            background-color: white;
            border: 1px solid #1f2937;
            color: black;
        }

        .card-red {
            color: #dc2626;
        }

        .card-placeholder {
            background-color: white;
            border: 1px solid #d1d5db;
        }

        .card-corner-top {
            position: absolute;
            top: 3px;
            left: 3px;
            font-size: 14px;
            font-weight: bold;
            line-height: 1.1;
            text-shadow: 0 0 2px rgba(255,255,255,0.8);
            background-color: rgba(255,255,255,0.9);
            padding: 1px 2px;
            border-radius: 2px;
            min-height: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            line-height: 1;
        }

        .card-corner-bottom {
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 14px;
            font-weight: bold;
            line-height: 1.1;
            transform: rotate(180deg);
            text-shadow: 0 0 2px rgba(255,255,255,0.8);
            background-color: rgba(255,255,255,0.9);
            padding: 1px 2px;
            border-radius: 2px;
            min-height: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .card-top-right-id {
            position: absolute;
            top: 3px;
            right: 3px;
            font-size: 10px;
            font-weight: bold;
            background-color: rgba(255,255,255,0.9);
            padding: 1px 3px;
            border-radius: 2px;
            text-shadow: 0 0 1px rgba(255,255,255,0.8);
            line-height: 1;
        }

        .card-selected {
            transform: translateY(-6px);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .card-shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }

        .stock-counter {
            position: absolute;
            bottom: -6px;
            right: -6px;
            background-color: #1e40af;
            color: white;
            font-size: 13px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .tableau {
            flex: 1;
            overflow: hidden;
            margin-bottom: 60px;
        }

        .tableau-columns {
            display: flex;
            gap: 3px;
            height: 100%;
        }

        .tableau-column {
            flex: 1;
            position: relative;
        }

        .instructions {
            text-align: center;
            color: #bbf7d0;
            font-size: 14px;
            margin-top: 8px;
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            padding: 0 10px;
        }

        .hidden {
            display: none;
        }

        /* General Desktop Override */
        @media screen and (min-width: 768px) {
            .card {
                width: 140px !important;
                height: 190px !important;
                border-radius: 14px;
                box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            }

            .card-back-pattern {
                width: 118px !important;
                height: 168px !important;
                border-radius: 12px;
            }

            .card-corner-top, .card-corner-bottom {
                font-size: 20px !important;
                min-height: 25px !important;
                padding: 3px 5px !important;
                border-radius: 4px;
            }

            .card-corner-top {
                top: 6px !important;
                left: 6px !important;
            }

            .card-corner-bottom {
                bottom: 6px !important;
                right: 6px !important;
            }

            .card-center {
                font-size: 28px !important;
            }

            .card-top-right-id {
                font-size: 16px !important;
                padding: 2px 6px !important;
                top: 6px !important;
                right: 6px !important;
            }

            .stock-counter {
                width: 28px !important;
                height: 28px !important;
                font-size: 16px !important;
                bottom: -12px !important;
                right: -12px !important;
            }
        }

        /* Landscape and Desktop Styles */
        @media screen and (orientation: landscape) and (min-width: 600px), 
               screen and (min-width: 900px) {
            body {
                padding: 12px;
                max-width: 1400px;
                margin: 0 auto;
            }

            .header {
                margin-bottom: 12px;
            }

            .status-info {
                font-size: 16px;
                min-width: 80px;
            }

            .win-count-number {
                font-size: 20px;
            }

            .win-count-label {
                font-size: 13px;
            }

            .button-group {
                gap: 12px;
            }

            .new-game-btn, .auto-win-btn {
                padding: 12px 20px;
                font-size: 16px;
                min-height: 48px;
                border-radius: 10px;
            }

            .auto-win-btn {
                min-width: 100px;
            }

            .new-game-btn {
                min-width: 80px;
            }

            .undo-btn {
                min-height: 48px;
                min-width: 48px;
                padding: 12px;
                font-size: 20px;
                border-radius: 10px;
            }

            .top-area {
                margin-bottom: 16px;
                justify-content: space-between;
            }

            .stock-waste {
                gap: 12px;
            }

            .foundations {
                gap: 12px;
            }

            .card {
                width: 80px;
                height: 110px;
                border-radius: 10px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            }

            .card-back-pattern {
                width: 60px;
                height: 90px;
                border-radius: 8px;
            }

            .card-corner-top, .card-corner-bottom {
                font-size: 16px;
                min-height: 20px;
                padding: 2px 3px;
                border-radius: 3px;
            }

            .card-corner-top {
                top: 4px;
                left: 4px;
            }

            .card-corner-bottom {
                bottom: 4px;
                right: 4px;
            }

            .card-center {
                font-size: 20px;
            }

            .card-top-right-id {
                font-size: 12px;
                padding: 1px 4px;
                border-radius: 3px;
                top: 4px;
                right: 4px;
            }

            .stock-counter {
                width: 24px;
                height: 24px;
                font-size: 14px;
                bottom: -8px;
                right: -8px;
            }

            .tableau {
                margin-bottom: 80px;
            }

            .tableau-columns {
                gap: 8px;
                max-height: calc(100vh - 200px);
            }

            .instructions {
                font-size: 16px;
                bottom: 20px;
                padding: 0 20px;
            }

            .win-popup-content {
                max-width: 400px;
                padding: 40px 32px;
                border-radius: 20px;
            }

            .win-popup h2 {
                font-size: 32px;
                margin-bottom: 20px;
            }

            .win-popup p {
                font-size: 18px;
                margin-bottom: 32px;
            }

            .win-popup-btn {
                padding: 20px 32px;
                font-size: 20px;
                border-radius: 16px;
                min-height: 64px;
            }
        }

        /* Large Desktop Styles */
        @media screen and (min-width: 1200px) {
            body {
                padding: 20px;
            }

            .card {
                width: 90px;
                height: 125px;
            }

            .card-back-pattern {
                width: 70px;
                height: 105px;
            }

            .card-corner-top, .card-corner-bottom {
                font-size: 18px;
                min-height: 22px;
                padding: 2px 4px;
            }

            .card-center {
                font-size: 24px;
            }

            .card-top-right-id {
                font-size: 14px;
                padding: 2px 5px;
            }

            .tableau-columns {
                gap: 12px;
            }

            .stock-waste, .foundations {
                gap: 16px;
            }
        }

        /* Mobile Portrait Optimizations (keep existing) */
        @media (max-height: 600px) and (orientation: portrait) {
            .tableau {
                margin-bottom: 45px;
            }
            .instructions {
                font-size: 13px;
                bottom: 10px;
            }
            .header {
                margin-bottom: 4px;
            }
            .top-area {
                margin-bottom: 6px;
            }
        }

        @media (max-width: 400px) and (orientation: portrait) {
            .card {
                width: 52px;
                height: 70px;
            }
            .card-back-pattern {
                width: 34px;
                height: 52px;
            }
            .card-center {
                font-size: 14px;
            }
            .card-corner-top, .card-corner-bottom {
                font-size: 12px;
                min-height: 14px;
                padding: 1px;
            }
            .card-top-right-id {
                font-size: 9px;
                padding: 1px 2px;
            }
            .foundations {
                gap: 4px;
            }
            .stock-waste {
                gap: 4px;
            }
            .tableau-columns {
                gap: 2px;
            }
            .new-game-btn, .auto-win-btn {
                padding: 6px 12px;
                font-size: 13px;
                min-height: 40px;
            }
            .auto-win-btn {
                min-width: 70px;
            }
            .new-game-btn {
                min-width: 50px;
            }
            .undo-btn {
                min-height: 40px;
                min-width: 40px;
                padding: 6px;
                font-size: 16px;
            }
            .button-group {
                gap: 6px;
            }
            .status-info {
                font-size: 12px;
                min-width: 50px;
            }
            .win-count-number {
                font-size: 15px;
            }
            .win-count-label {
                font-size: 10px;
            }
        }

        /* Mobile Landscape Optimizations */
        @media screen and (orientation: landscape) and (max-width: 800px) and (max-height: 500px) {
            body {
                padding: 8px;
            }

            .header {
                margin-bottom: 8px;
            }

            .top-area {
                margin-bottom: 8px;
            }

            .card {
                width: 60px;
                height: 80px;
            }

            .card-back-pattern {
                width: 44px;
                height: 64px;
            }

            .card-corner-top, .card-corner-bottom {
                font-size: 12px;
                min-height: 16px;
                padding: 1px 2px;
            }

            .card-center {
                font-size: 16px;
            }

            .card-top-right-id {
                font-size: 10px;
                padding: 1px 3px;
            }

            .tableau {
                margin-bottom: 50px;
            }

            .tableau-columns {
                gap: 4px;
            }

            .stock-waste, .foundations {
                gap: 8px;
            }

            .instructions {
                font-size: 13px;
                bottom: 12px;
            }

            .new-game-btn, .auto-win-btn {
                padding: 8px 14px;
                font-size: 14px;
                min-height: 40px;
            }

            .undo-btn {
                min-height: 40px;
                min-width: 40px;
                padding: 8px;
                font-size: 16px;
            }

            .status-info {
                font-size: 14px;
            }

            .win-count-number {
                font-size: 17px;
            }

            .win-count-label {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="status-info">
            <div id="winCounter" class="win-counter">
                <div id="winCountNumber" class="win-count-number">0</div>
                <div class="win-count-label">wins</div>
            </div>
        </div>
        <div class="button-group">
            <button id="undoBtn" class="undo-btn" disabled>
                <span class="undo-icon">↩</span>
            </button>
            <button id="autoWinBtn" class="auto-win-btn hidden">Auto-Win</button>
            <button id="newGameBtn" class="new-game-btn">New</button>
        </div>
    </div>

    <div class="top-area">
        <div class="stock-waste">
            <div style="position: relative;">
                <div id="stockPile" class="card card-placeholder"></div>
                <div id="stockCounter" class="stock-counter hidden"></div>
            </div>
            <div id="wastePile" class="card card-placeholder"></div>
        </div>

        <div class="foundations">
            <div id="foundation0" class="card card-placeholder"></div>
            <div id="foundation1" class="card card-placeholder"></div>
            <div id="foundation2" class="card card-placeholder"></div>
            <div id="foundation3" class="card card-placeholder"></div>
        </div>
    </div>

    <div class="tableau">
        <div class="tableau-columns">
            <div id="tableau0" class="tableau-column"></div>
            <div id="tableau1" class="tableau-column"></div>
            <div id="tableau2" class="tableau-column"></div>
            <div id="tableau3" class="tableau-column"></div>
            <div id="tableau4" class="tableau-column"></div>
            <div id="tableau5" class="tableau-column"></div>
            <div id="tableau6" class="tableau-column"></div>
        </div>
    </div>

    <div id="instructions" class="instructions">
        Click cards to auto-move to the best available pile
    </div>

    <div id="winPopup" class="win-popup hidden">
        <div class="win-popup-content">
            <h2>🎉 You Won!</h2>
            <p>Congratulations! You've successfully completed the game.</p>
            <button id="newGameFromPopup" class="win-popup-btn">New Game</button>
        </div>
    </div>

    <script>
        const SUITS = ['♠', '♥', '♦', '♣'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        let gameState = {
            stock: [],
            waste: [],
            foundations: [[], [], [], []],
            tableau: [[], [], [], [], [], [], []],
            gameWon: false,
            autoWinning: false
        };

        let moveHistory = [];
        const MAX_HISTORY = 100; // Limit history to prevent memory issues

        // Win counter functionality
        function getWinCount() {
            try {
                return parseInt(localStorage.getItem('klondike-win-count') || '0', 10);
            } catch (e) {
                return 0;
            }
        }

        function incrementWinCount() {
            try {
                const currentCount = getWinCount();
                const newCount = currentCount + 1;
                localStorage.setItem('klondike-win-count', newCount.toString());
                updateWinCountDisplay();
                return newCount;
            } catch (e) {
                console.warn('Unable to save win count to localStorage');
                return getWinCount();
            }
        }

        function updateWinCountDisplay() {
            const winCountNumber = document.getElementById('winCountNumber');
            const currentCount = getWinCount();
            winCountNumber.textContent = currentCount;
        }

        function deepCopyGameState(state) {
            // Only save tableau and foundations, not stock/waste
            return {
                foundations: state.foundations.map(pile => pile.map(card => ({...card}))),
                tableau: state.tableau.map(column => column.map(card => ({...card}))),
                gameWon: state.gameWon,
                autoWinning: state.autoWinning
            };
        }

        function saveGameState(moveInfo = null) {
            const state = deepCopyGameState(gameState);
            state.moveInfo = moveInfo; // Save info about what move was made
            moveHistory.push(state);

            // Limit history size
            if (moveHistory.length > MAX_HISTORY) {
                moveHistory.shift();
            }

            updateUndoButton();
        }

        function undo() {
            if (moveHistory.length > 0) {
                const previousState = moveHistory.pop();

                // If the move involved taking a card from waste, put it back in stock
                if (previousState.moveInfo && previousState.moveInfo.fromWaste) {
                    const cardToRestore = previousState.moveInfo.cardMoved;
                    cardToRestore.faceUp = false; // Put it back face down in stock
                    // Add to bottom of stock pile so counter increases
                    gameState.stock = [...gameState.stock, cardToRestore];
                }

                // Only restore tableau and foundations, keep current stock position
                gameState.foundations = previousState.foundations;
                gameState.tableau = previousState.tableau;
                gameState.gameWon = previousState.gameWon;
                gameState.autoWinning = previousState.autoWinning;

                updateUndoButton();
                renderGame();
            }
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            undoBtn.disabled = moveHistory.length === 0;
        }

        function clearHistory() {
            moveHistory = [];
            updateUndoButton();
        }

        function createDeck() {
            const deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({
                        suit,
                        rank,
                        id: `${rank}-${suit}`,
                        faceUp: false,
                        red: suit === '♥' || suit === '♦'
                    });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCardElement(card, placeholder = false, hasCardAbove = false) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.dataset.cardId = card ? card.id : '';

            if (placeholder) {
                cardEl.classList.add('card-placeholder');
                return cardEl;
            }

            if (!card.faceUp) {
                cardEl.classList.add('card-face-down');
                cardEl.innerHTML = '<div class="card-back-pattern"></div>';
                return cardEl;
            }

            cardEl.classList.add('card-face-up');
            if (card.red) cardEl.classList.add('card-red');

            // Only add the top-right identifier if there's a card above this one
            const topRightId = hasCardAbove ? `<div class="card-top-right-id">${card.suit}</div>` : '';

            cardEl.innerHTML = `
                <div class="card-corner-top">
                    <div>${card.rank}</div>
                    <div>${card.suit}</div>
                </div>
                ${topRightId}
                <div class="card-center">${card.suit}</div>
                <div class="card-corner-bottom">
                    <div>${card.rank}</div>
                    <div>${card.suit}</div>
                </div>
            `;

            return cardEl;
        }

        function dealCards() {
            const deck = shuffleDeck(createDeck());
            gameState.tableau = [[], [], [], [], [], [], []];
            let cardIndex = 0;

            // Deal tableau cards
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = deck[cardIndex++];
                    card.faceUp = row === col;
                    gameState.tableau[col].push(card);
                }
            }

            gameState.stock = deck.slice(cardIndex);
            gameState.waste = [];
            gameState.foundations = [[], [], [], []];
            gameState.gameWon = false;
            gameState.autoWinning = false;

            console.log(`Dealt ${cardIndex} cards to tableau, ${gameState.stock.length} cards to stock`);

            // Clear move history when starting new game
            clearHistory();

            hideWinPopup();
            renderGame();
        }

        function drawFromStock() {
            if (gameState.autoWinning) return;

            if (gameState.stock.length > 0) {
                const drawnCard = gameState.stock[0];
                console.log(`Drawing 1 card from stock (${gameState.stock.length} -> ${gameState.stock.length - 1})`);
                drawnCard.faceUp = true;
                gameState.waste = [drawnCard, ...gameState.waste];
                gameState.stock = gameState.stock.slice(1);
            } else if (gameState.waste.length > 0) {
                console.log(`Recycling ${gameState.waste.length} cards from waste back to stock`);
                const resetStock = [...gameState.waste].reverse();
                resetStock.forEach(card => card.faceUp = false);
                gameState.stock = resetStock;
                gameState.waste = [];
            }

            renderGame();
        }

        function canPlaceOnFoundation(card, foundationIndex) {
            const foundation = gameState.foundations[foundationIndex];
            if (foundation.length === 0) {
                return card.rank === 'A';
            }
            const topCard = foundation[foundation.length - 1];
            return card.suit === topCard.suit && 
                   RANKS.indexOf(card.rank) === RANKS.indexOf(topCard.rank) + 1;
        }

        function canPlaceOnTableau(cards, columnIndex) {
            const column = gameState.tableau[columnIndex];
            if (column.length === 0) {
                return cards[0].rank === 'K';
            }
            const topCard = column[column.length - 1];
            const firstCard = cards[0];
            return topCard.red !== firstCard.red && 
                   RANKS.indexOf(firstCard.rank) === RANKS.indexOf(topCard.rank) - 1;
        }

        function isAutoWinnable() {
            // Game is auto-winnable if all cards are face-up and can be moved to foundations
            if (gameState.stock.length > 0) return false;

            // Check if all tableau cards are face-up
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                for (let card of column) {
                    if (!card.faceUp) return false;
                }
            }

            // Check if all remaining cards can eventually reach foundations
            // We'll do this by simulating the moves
            return canCompleteGame();
        }

        function canCompleteGame() {
            // Create a copy of the current state to test
            const testState = {
                waste: [...gameState.waste],
                foundations: gameState.foundations.map(f => [...f]),
                tableau: gameState.tableau.map(col => [...col])
            };

            let madeProgress = true;
            while (madeProgress) {
                madeProgress = false;

                // Try to move cards to foundations
                // Check waste pile
                if (testState.waste.length > 0) {
                    const card = testState.waste[0];
                    for (let i = 0; i < 4; i++) {
                        if (canPlaceOnFoundationInState(card, i, testState)) {
                            testState.foundations[i].push(card);
                            testState.waste.shift();
                            madeProgress = true;
                            break;
                        }
                    }
                }

                // Check tableau columns
                for (let col = 0; col < 7; col++) {
                    const column = testState.tableau[col];
                    if (column.length > 0) {
                        const topCard = column[column.length - 1];
                        if (topCard.faceUp) {
                            for (let i = 0; i < 4; i++) {
                                if (canPlaceOnFoundationInState(topCard, i, testState)) {
                                    testState.foundations[i].push(topCard);
                                    testState.tableau[col].pop();
                                    madeProgress = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // Check if all cards are in foundations
            const totalInFoundations = testState.foundations.reduce((sum, pile) => sum + pile.length, 0);
            return totalInFoundations === 52;
        }

        function canPlaceOnFoundationInState(card, foundationIndex, state) {
            const foundation = state.foundations[foundationIndex];
            if (foundation.length === 0) {
                return card.rank === 'A';
            }
            const topCard = foundation[foundation.length - 1];
            return card.suit === topCard.suit && 
                   RANKS.indexOf(card.rank) === RANKS.indexOf(topCard.rank) + 1;
        }

        function executeAutoWin() {
            if (gameState.autoWinning) return;
            gameState.autoWinning = true;

            const autoWinBtn = document.getElementById('autoWinBtn');
            autoWinBtn.classList.add('hidden');

            // Move all cards instantly to foundations in proper order
            let madeProgress = true;
            while (madeProgress && !gameState.gameWon) {
                madeProgress = false;

                // Check waste pile first
                if (gameState.waste.length > 0) {
                    const card = gameState.waste[0];
                    for (let i = 0; i < 4; i++) {
                        if (canPlaceOnFoundation(card, i)) {
                            gameState.waste.shift();
                            gameState.foundations[i].push(card);
                            madeProgress = true;
                            break;
                        }
                    }
                }

                // Check tableau columns
                if (!madeProgress) {
                    for (let col = 0; col < 7 && !madeProgress; col++) {
                        const column = gameState.tableau[col];
                        if (column.length > 0) {
                            const topCard = column[column.length - 1];
                            if (topCard.faceUp) {
                                for (let i = 0; i < 4; i++) {
                                    if (canPlaceOnFoundation(topCard, i)) {
                                        gameState.tableau[col].pop();

                                        // Flip next card if needed
                                        if (gameState.tableau[col].length > 0) {
                                            const nextCard = gameState.tableau[col][gameState.tableau[col].length - 1];
                                            if (!nextCard.faceUp) {
                                                nextCard.faceUp = true;
                                            }
                                        }

                                        gameState.foundations[i].push(topCard);
                                        madeProgress = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                checkWin();
            }

            gameState.autoWinning = false;
            renderGame();

            // Show win popup after a brief delay to let player see the completed layout
            if (gameState.gameWon) {
                setTimeout(() => {
                    showWinPopup();
                }, 500);
            }
        }

        function showWinPopup() {
            const winPopup = document.getElementById('winPopup');
            winPopup.classList.remove('hidden');
        }

        function hideWinPopup() {
            const winPopup = document.getElementById('winPopup');
            winPopup.classList.add('hidden');
        }

        function moveCards(cards, fromSource, fromIndex, toSource, toIndex) {
            if (fromSource === 'tableau' && toSource === 'tableau') {
                // Remove cards from source
                gameState.tableau[fromIndex] = gameState.tableau[fromIndex].slice(0, -cards.length);
                // Add cards to destination
                gameState.tableau[toIndex] = [...gameState.tableau[toIndex], ...cards];
                // Flip the next card if needed
                if (gameState.tableau[fromIndex].length > 0) {
                    const lastCard = gameState.tableau[fromIndex][gameState.tableau[fromIndex].length - 1];
                    if (!lastCard.faceUp) {
                        lastCard.faceUp = true;
                    }
                }
                return;
            }

            // Handle removing from source
            if (fromSource === 'waste') {
                gameState.waste = gameState.waste.slice(1);
            } else if (fromSource === 'tableau') {
                gameState.tableau[fromIndex] = gameState.tableau[fromIndex].slice(0, -cards.length);
                if (gameState.tableau[fromIndex].length > 0) {
                    const lastCard = gameState.tableau[fromIndex][gameState.tableau[fromIndex].length - 1];
                    if (!lastCard.faceUp) {
                        lastCard.faceUp = true;
                    }
                }
            } else if (fromSource === 'foundation') {
                gameState.foundations[fromIndex] = gameState.foundations[fromIndex].slice(0, -1);
            }

            // Handle adding to destination
            if (toSource === 'foundation') {
                gameState.foundations[toIndex] = [...gameState.foundations[toIndex], ...cards];
            } else if (toSource === 'tableau') {
                gameState.tableau[toIndex] = [...gameState.tableau[toIndex], ...cards];
            }
        }

        function findBestDestination(cards) {
            // First try foundations (prefer foundations over tableau)
            for (let i = 0; i < 4; i++) {
                if (cards.length === 1 && canPlaceOnFoundation(cards[0], i)) {
                    return { type: 'foundation', index: i };
                }
            }

            // Then try tableau columns
            for (let i = 0; i < 7; i++) {
                if (canPlaceOnTableau(cards, i)) {
                    return { type: 'tableau', index: i };
                }
            }

            return null;
        }

        function getMoveableCards(source, sourceIndex, cardIndex) {
            if (source === 'waste') {
                return gameState.waste.length > 0 ? [gameState.waste[0]] : [];
            } else if (source === 'foundation') {
                const foundation = gameState.foundations[sourceIndex];
                return foundation.length > 0 ? [foundation[foundation.length - 1]] : [];
            } else if (source === 'tableau') {
                const column = gameState.tableau[sourceIndex];
                if (cardIndex >= column.length) return [];

                // Get all face-up cards from this position to the end
                const availableCards = column.slice(cardIndex).filter(c => c.faceUp);

                // Verify they form a valid descending sequence with alternating colors
                if (availableCards.length <= 1) return availableCards;

                for (let i = 0; i < availableCards.length - 1; i++) {
                    const current = availableCards[i];
                    const next = availableCards[i + 1];

                    if (current.red === next.red || 
                        RANKS.indexOf(current.rank) !== RANKS.indexOf(next.rank) + 1) {
                        return availableCards.slice(0, i + 1);
                    }
                }

                return availableCards;
            }
            return [];
        }

        function shakeCard(cardElement) {
            cardElement.classList.add('card-shake');
            setTimeout(() => {
                cardElement.classList.remove('card-shake');
            }, 500);
        }

        function handleCardClick(card, source, sourceIndex, cardIndex, cardElement) {
            if (gameState.autoWinning) return;

            const moveableCards = getMoveableCards(source, sourceIndex, cardIndex);

            if (moveableCards.length === 0) {
                shakeCard(cardElement);
                return;
            }

            const destination = findBestDestination(moveableCards);

            if (destination) {
                // Create move info to track what happened
                const moveInfo = {
                    fromWaste: source === 'waste',
                    cardMoved: source === 'waste' ? {...moveableCards[0]} : null
                };

                // Save state before making move
                saveGameState(moveInfo);

                moveCards(moveableCards, source, sourceIndex, destination.type, destination.index);
                renderGame();
                checkWin();
            } else {
                shakeCard(cardElement);
            }
        }

        function checkWin() {
            const totalFoundationCards = gameState.foundations.reduce((sum, pile) => sum + pile.length, 0);
            if (totalFoundationCards === 52) {
                gameState.gameWon = true;
                
                // Increment win counter
                incrementWinCount();
                
                // Only show popup if not in auto-win mode (auto-win handles its own popup timing)
                if (!gameState.autoWinning) {
                    setTimeout(() => {
                        showWinPopup();
                    }, 300);
                }
            }
        }

        function getCardSpacing() {
            // Adjust card spacing based on screen size and orientation
            if (window.innerWidth >= 1600) {
                return 36; // Extra large screens with 170px tall cards
            } else if (window.innerWidth >= 1200) {
                return 34; // Large desktop with 150px tall cards
            } else if (window.matchMedia('(orientation: landscape) and (min-width: 600px)').matches || 
                       window.matchMedia('(min-width: 900px)').matches) {
                return 30; // Desktop/landscape with 130px tall cards
            } else if (window.matchMedia('(orientation: landscape) and (max-width: 800px)').matches) {
                return 16; // Mobile landscape
            } else if (window.innerWidth <= 400) {
                return 18; // Small mobile
            }
            return 20; // Default mobile portrait
        }

        function renderGame() {
            // Update auto-win button
            const autoWinBtn = document.getElementById('autoWinBtn');
            if (!gameState.gameWon && !gameState.autoWinning && isAutoWinnable()) {
                autoWinBtn.classList.remove('hidden');
            } else {
                autoWinBtn.classList.add('hidden');
            }

            // Update instructions
            const instructions = document.getElementById('instructions');
            if (!gameState.gameWon && !gameState.autoWinning) {
                instructions.classList.remove('hidden');
            } else {
                instructions.classList.add('hidden');
            }

            // Render stock pile
            const stockPile = document.getElementById('stockPile');
            const stockCounter = document.getElementById('stockCounter');
            stockPile.innerHTML = '';
            if (gameState.stock.length > 0) {
                stockPile.appendChild(createCardElement({ faceUp: false }, false, false));
                stockPile.onclick = drawFromStock;
                stockCounter.textContent = gameState.stock.length;
                stockCounter.classList.remove('hidden');
            } else {
                stockPile.appendChild(createCardElement(null, true, false));
                stockPile.onclick = drawFromStock;
                stockCounter.classList.add('hidden');
            }

            // Render waste pile
            const wastePile = document.getElementById('wastePile');
            wastePile.innerHTML = '';
            if (gameState.waste.length > 0) {
                const card = gameState.waste[0];
                const cardEl = createCardElement(card, false, false);
                cardEl.onclick = () => handleCardClick(card, 'waste', 0, 0, cardEl);
                wastePile.appendChild(cardEl);
            } else {
                wastePile.appendChild(createCardElement(null, true, false));
            }

            // Render foundations
            for (let i = 0; i < 4; i++) {
                const foundation = document.getElementById(`foundation${i}`);
                foundation.innerHTML = '';
                if (gameState.foundations[i].length > 0) {
                    const card = gameState.foundations[i][gameState.foundations[i].length - 1];
                    const cardEl = createCardElement(card, false, false);
                    cardEl.onclick = () => handleCardClick(card, 'foundation', i, gameState.foundations[i].length - 1, cardEl);
                    foundation.appendChild(cardEl);
                } else {
                    const placeholder = createCardElement(null, true, false);
                    foundation.appendChild(placeholder);
                }
            }

            // Render tableau
            const cardSpacing = getCardSpacing();
            for (let col = 0; col < 7; col++) {
                const column = document.getElementById(`tableau${col}`);
                column.innerHTML = '';

                if (gameState.tableau[col].length === 0) {
                    const placeholder = createCardElement(null, true);
                    column.appendChild(placeholder);
                } else {
                    gameState.tableau[col].forEach((card, cardIndex) => {
                        // Check if there's a card above this one (not the last card in the column)
                        const hasCardAbove = cardIndex < gameState.tableau[col].length - 1;
                        const cardEl = createCardElement(card, false, hasCardAbove);
                        cardEl.style.position = 'absolute';
                        cardEl.style.top = `${cardIndex * cardSpacing}px`;
                        cardEl.style.zIndex = cardIndex;

                        cardEl.onclick = () => handleCardClick(card, 'tableau', col, cardIndex, cardEl);
                        column.appendChild(cardEl);
                    });
                }
            }
        }

        // Initialize game
        document.getElementById('newGameBtn').onclick = dealCards;
        document.getElementById('newGameFromPopup').onclick = dealCards;
        document.getElementById('autoWinBtn').onclick = executeAutoWin;
        document.getElementById('undoBtn').onclick = undo;
        
        // Initialize win counter display
        updateWinCountDisplay();
        
        // Handle window resize to update card spacing
        window.addEventListener('resize', () => {
            renderGame();
        });
        
        dealCards();
    </script>
</body>
</html>
